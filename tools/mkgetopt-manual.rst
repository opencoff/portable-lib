NAME
====
mkgetopt.py - is a python script to generate type-safe, ``getopt_long()``
option parsing routines.

SYNOPSIS
========
mkgetopt.py [options] inputfile

mkgetopt.py - is a python script to generate type-safe, ``getopt_long()``
option parsing routines.

The script reads an input specification file inputfile containing the
command line options that must be understood by a C/C++ program. It
generates two files - a "C" header file and a "C" source file.

Options
-------
Optional arguments are:

--output-prefix=p, -o p
    Use 'p' as the prefix for the output files. If this options is not
    used, the prefix is derived from the name of the input file by
    discarding everything past the *last* ``.`` (dot) character. The
    output "C" file has a ``.c`` suffix and the header file has a ``.h``
    suffix.

    e.g.,

    input filename=opt.in output prefix=opt, cfile=opt.c, header
    file=opt.h

    input filename=opt.x.in output prefix=opt.x cfile=opt.x.c header
    file=opt.x.h

--header=f, -h f
    Use 'f' as the output header filename. If this option is used, it
    overrides the --output-prefix option.

--source=f, -s f
    Use 'f' as the output source filename. If this option is used, it
    overrides the --output-prefix option.

--sym-prefix=s
    Use 's' as the prefix for all generated *symbols*: functions, struct
    tags., etc. Any '%prefix' directive present in the input file will
    over-ride this command line parameter.

--help, -h
    Show this help message and quit.

--man, --verbose-help
    Show a man page with examples and more details.

DESCRIPTION
===========
The program reads an input file describing the command line options that
must be understood by a C/C++ program and, generates a function to parse
the command line options. The parsed options are filled into a ``struct``
for easy retrieval by the programmer. The ``struct`` tag and definition
are autogenerated from the input file.

The program generates two output files. The names of the generated files
are derived from the input file by stripping the suffix and replacing it
with either .c or .h. e.g., if the input file is called opt.in, then,
the output files are opt.c and opt.h.

C File
------
The ``C`` source file contains a function for parsing the command line
options.  This file exports a single global function with "C" linkage. By
default it is called ``opt_parse()``. The prefix ``main_`` is the
default prefix; it can be changed by different means. See succeeding
sections to understand more.

The generated function has the following prototype::

    extern "C" int opt_parse(int argc, char * const *argv);

The return value of this function is 0 if the command line arguments
were successfully parsed and non-zero otherwise.

If the return value is non-zero, the ``getopt_long()`` library
would've emited suitable error messages for un-recognized options or
other errors. Thus, the only action to be taken in this case is to
exit the program or re-accept the command line arguments.

The ``opt_parse()`` function uses the well known ``getopt_long()``
function as well as the GNU ``error()`` functions. Other than these two external
functions, the generated code uses only the standard "C" library. In
case the function ``error()`` is not available, a simple
implementation is as follows::

    #include <errno.h>
    #include <stdarg.h>
    #include <stdio.h>
    #include <stdlib.h>

    void error(int status, int errnum, const char * message, ...)
    {
        va_list ap;

        fflush(stdout);
        fflush(stderr);

        if (errnum < 0)
            errnum = -errnum;

        va_start(ap, message);
        vfprintf(stderr, message, ap);

        if (errnum)
            fprintf(stderr, ": %s", strerror(errnum));

        fputc('\n', stderr);
        fflush(stderr);

        if (status)
            exit(status);
    }

For those users not wishing to use the GNU GPL version of
``getopt_long()`` NetBSD has an excellent implementation of the same
function but licensed under BSD terms.


H File
------
The header file contains structure definitions and prototypes for
the functions that are provided in the ``.c`` file. In addition, if
the generated ``.c`` file requires additional functions to be
implemented by the programmer, then their prototypes are also listed
in the header file.

The default name for the generated struct is ``opt_option``. As
explained before, the prefix ``main`` can be changed via inline
directives in the input file or the command line.

For each option specified in the option input file, the struct
contains two members:

#. One member representing the option
    This member has a type that appropriately represents the option
    (e.g., ``int``, ``char *``, ``char``, etc.)

#. One boolean member indicating if an option was used
    This member is always typed as ``char`` and its name has the form
    ``NAME_present`` where ``NAME`` is the name of the member
    corresponding to the option (i.e., ``NAME`` is identical to the
    member name mentioned in the step 1. above). See an example
    later on for more details.

The default prefix for all the generated symbols is ``main``. i.e., the
option parsing function is called ``opt_parse()``, the ``struct``
defining the options is called ``struct opt_opt`` etc.

The prefix used in the generated symbols can be changed by the %prefix
directive inside the option specification file or by the ``--sym-prefix``
command line option. When both are specified, the directive inside the
option specification file takes precedence (i.e., the command line
option ``--sym-prefix`` is ignored).

Example Usage
-------------
Let us assume that the input file describing the command line options is
opt.in. And, let us assume that it contains::

 # example option file opt.in

 %description "Example program to show mkgetopt.py"

 # format:
 # long-opt short-opt  struct-member-name type default-value description

  jobs      j   njobs       int   1          "Use 'J' jobs simultaneously"
  use-proxy -   use_proxy_p bool false       "Use the default proxy server"
  foreground f  fg_p        bool false       "Run in the foreground"
  debug      -  debug       string "syslog"  "Send debug messages to 'D'"

Then, the following call will generate two files opt.c and opt.h.::

    mkgetopt.py opt.in

The file opt.h has the following struct definitions::

    struct opt_option
    {
        char * const* argv_inputs;
        int     argv_count;

        int njobs;
        int use_proxy_p;
        int fg_p;
        char * debug;

        char njobs_present;
        char use_proxy_p_present;
        char fg_p_present;
        char debug_present;
    };
    typedef struct opt_option opt_option;

Note that for each command line option, there is a corresponding "flag"
variable of the form ``NAME_present`` where ``NAME`` is one of
``njobs`` ``use_proxy_p`` ``fg_p`` ``debug`` These ``NAME_present``
flags are lit
whenever the corresponding command line option is present(or used).

The file opt.c contains the implementation of ``opt_parse()``

These two files are used as follows::

    #include <stdio.h>

    // this auto-generated .h file provides definitions for
    // opt_opt and opt_parse()
    #include "opt.h"


    int main(int argc, char * argv [])
    {
        // Define an instance of the struct defined in opt.h
        opt_opt    opt;

        memset(&opt, 0, sizeof(opt));

        if ( 0 != opt_parse(&opt, argc, argv) )
            exit (1);


        if ( opt.use_proxy_p )
        {
            // setup to handle communication via default proxy server
            // ...
        }

        if ( 0 == strcmp(opt.debug, "syslog") )
        {
            // setup debug via syslog
        }
        else if ( 0 == strncmp(opt.debug, "/", 1) )
        {
            // setup debug via a file in the file-system
        }
        else if ( 0 == strncmp(opt.debug, "tcp://", 6) )
        {
            // setup debug via network logging
        }

        if ( opt.jobs > 1 )
        {
            // fork n copies of self to handle multiple jobs
        }

        // .. other stuff.

        return 0;
    }

As you can see, parsing the options is very easy. All the messy logic of
dealing with long and short options are handled by opt.c.

INPUT FILE FORMAT
=================
The input file consists of one or more lines. Each line can be a comment
line, a directive or an option line.

Comment Lines
-------------
Comment lines begin with the '#' character. Comments are recognized if
and only if '#' is the first non white-space character of a line.

Empty lines or lines consisting of *all* white spaces are treated as
comment lines.

e.g.,::

    # This is a comment line

Directive Lines
---------------
Directives change the default or builtin behaviour of
``mkgetopt.py`` They also provide hooks to augment the
(often simplistic) default behaviour.

Some of the default behaviour(s) can be changed via the command line
options. However, directives (if present) always over-ride the command
line options. Thus, it is recommended that programmers use directives
whenever possible.

It is always best to set the directives at the beginning of the input
file to make its meaning clear.

Each directive starts with "%" character and is immediately followed by
a word. The available directives are:

``%description``
    Provide a one line textual description of the program in question.
    If a multi-line description is required, then use multiple
    %description directives.

    An example of a single line description::

        # One line description
        %description "A utility to resolve conflicts"

    An example of a multi-line description::

        %description "A utility to perform checks on file-systems"
        %description "using cryptographic techniques to store checksums"


``%usage_call``
    In cases where the usage needs to be more detailed and possibly
    involving other conditions (``#define``, etc.), this directive
    provides a hook to use a user-defined callback function to return a
    string containing the usage. The argument to this directive is the
    name of a function that will be called to obtain the usage string.
    Such a function must have "C" linkage and the following
    prototype::

            const char * FUNCTION_NAME (void)

    e.g.,::

        %usage_call  myprog_usage_string

    And, the programmer must define a function called
    ``myprog_usage_string()`` as follows::

        const char * myprog_usage_string ()
        {
            static char buf[1024];

            // body of this function to generate the usage string
            // via some means

            return buf;
        }

``%prefix``
    This directive is similar to the --sym-prefix command line option.
    When present, it overrides the command line option. It defines the
    prefix to be used for all generated symbols such as functions,
    struct tags, etc.

    e.g.,::

        %prefix     foo_opt

    In the above example, the tool will use the prefix ``foo_opt`` for all
    "C" symbols it generates. The default prefix is ``opt``.

    This option is very important as it allows multiple instances of
    command line parsing routines to be used within a single program.
    e.g., in an application which has "subcommands" with options ala CVS
    or SVN.

``%nopermute``
    This directive tells the underlying ``getopt_long()`` option parser
    not to *permute* command line flags. See the man pages for
    ``getopt_long()`` for more details.

    This option is useful when the order of options matter. e.g., in a
    tool such as CVS or SVN, one would use this directive for parsing
    the "global" options to the command (i.e., options that come before
    the sub-command). A second option parsing input file will NOT use
    this directive (e.g., when used to parse options for sub-commands).

    The default is to permute arguments.

``%noversion``
    This directive tells the tool NOT to generate any functions or flags
    that display the programs version i.e., do not recognize the
    ``--version`` command line option. Here, the term "program" refers to
    the final program that uses the output generated by this tool.

    The default is to recognize the options ``--version`` and ``-v``

``%nohelp``
    This directive tells the tool NOT to generate any functions or flags
    that display "help" i.e., do not recognize the ``--help`` command line
    option. Here, the term "program" refers to the final program that
    uses the output generated by this tool.

    The default is to recognize the options ``--help`` ``-h``.

Option lines
------------
Option lines are the most important part of the input specification.
Each option line describes one command line option that your program
will be handling. Each option line consists of 6 different "fields".
Each field is separated by one or more white spaces. The content for
each field can be quoted via single or double quotes. The fields are:

1. Long option name:

   This field is the GNU style long option name. If you don't have a
   long option name, use a lone '"-"' symbol ("dash" or "minus").

2. Short option character:

   This field is a one-character option name for the corresponding long
   option (above). If you don't have a long option name, use a lone
   '"-"' symbol ("dash" or minus").

3. Member Name (within the option struct):

   This field is the name of the struct member that will hold the
   result when the user uses either the long or short option. This name
   must be a valid C identifier.

   If both short & long options are missing (i.e., they are both
   '"-"'), then the option line is treated as a "place holder" for a
   struct member of the given type. In this case, the generated
   functions do not use such a member variable in any way; it is
   present in the generated header file (``struct opt_option``) for use
   by the programmer in whatever fashion they choose.

4. Option Type:

   This field denotes the type of the option (e.g., ``int``,
   ``string``,
   ``boolean`` etc.). This is translated into the nearest C data type.
   e.g., ``boolean`` is translated into an ``int``; ``string`` is translated
   into a ``char *``.

5. default value for the option

   If the option should have a default value, this this field must have
   an appropriately typed default value.

6. Description (or help string) for the option:

    This field contains a descriptive & brief help string for this
    particular option. It will be displayed automatically when the user
    types ``--help``.

e.g., to describe a command line option to denote whether the program
must run in the foreground or not, the following is the option
line::

    # long-opt short-opt  member-name type default description
    foreground    f       stay_in_fg  bool false   "Keep program in foreground"

In the above example, the long option that your final program will
recognize is ``--foreground``, and the corresponding short option is
``-f``.
Using this option will set the struct member called ``stay_in_fg`` to
"true" (1). If the command line option is not used, the member
``stay_in_fg`` will have the default value of "false".

Option Types
------------
Option type can be one of the following:

``short``:
    A signed 2 byte quantity

``int``:
    A signed 4 byte quantity

``long``:
    A signed 4 (or 8 byte) quantity

``ushort``:
    An unsigned 2 byte quantity

``uint``:
    An unsigned 4 byte quantity

``ulong``:
    An unsigned 4 (or 8 byte) quantity

``string``:
    A null terminated string (``char *``)

``flag``, ``boolean``:
    A flag or boolean option; represented in the C program as an ``int``.


``callback``, ``callback_arg``:
    A C function pointer name. This function pointer should have
    the following signature::

        void (*)(struct option * opt, char * optarg)

    The struct ``struct option`` is the struct that will be defined by
    this script and it will hold the command line option parsing results
    (it will be named appropriately by honoring any sym-prefix
    settings).

    The ``callback`` type does not take an mandatory argument to the option
    (i.e., ``optarg`` will always be NULL in the callback function) while
    the ``callback_arg`` variant will *always* take a mandatory argument to
    be passed to the callback function.


A type can optionally have a suffix of "**?**". In such a case, the argument
to that command line option is considered optional. e.g. consider the
following input line specification::

    debug   d debug_level  int?  0 "Debug Level"

Then, if the command line invocation of this option is::

    --debug

Then, the member ``debug_level`` is set to 1 -- since it was invoked once.
On the other hand, if the program invocation of this option is::

    --debug --debug --debug

Then, the member ``debug_level`` is set to 3 -- indicating it was called
"3" times. Further more, if the invocation of this option is::

    --debug=180

Then, the member ``debug_level`` is set to 180 (which is the argument to
this option).

In any case, the "flag" member ``debug_present`` is set to 1 - to indicate
that the option was used.

Required vs. Optional Fields
----------------------------
All types except "flag", "boolean" and "callback" take arguments. By
default, the arguments are *required*.

EXAMPLES
========
The sections below show several examples to illustrate the various
combinations of directives and options.

Simple example file
-------------------
The following is a simple example input file::

    %description "Example program to show mkgetopt.py"

    # format:
    # long-opt short-opt  struct-member-name type default-value description

    jobs      j   njobs       int   1          "Use 'J' jobs simultaneously"
    use-proxy -   use_proxy_p bool false       "Use the default proxy server"
    foreground f  fg_p        bool false       "Run in the foreground"
    debug      -  debug       string "syslog"  "Send debug messages to 'D'"
    log-level  L  loglevel    int?  0          "Default log level"

When "mkgetopt.py" is invoked as "mkgetopt.py example.in", it generates
two files: example.c and example.h. The header file example.h contains
the definition of the following structure::

    struct opt_option
    {
        /* Points to remaining/unconsumed command line arguments.
         * These are unconsumed either because:
         *   1. The argument parsing was explicitly stopped by use of
         *      the "--" command line option.
         *   2. There are no more options (starting with "-" or "--")
         */
        char * const * argv_inputs;

        /*
         * Contains a count of remaining command line arguments in
         * 'argv_inputs' above.
         */
        int     argv_count;

        int somevar;
        int njobs;
        int use_proxy_p;
        int fg_p;
        char * debug;
        int loglevel;

        char njobs_present;
        char use_proxy_p_present;
        char fg_p_present;
        char debug_present;
        char loglevel_present;
    };

Note that for each option variable mentioned in the 3rd field of the
input file, there is a corresponding variable in ``struct opt_option``.
Furthermore, for each such variable, there is a corresponding flag
variable of the form ``NAME_present`` where "NAME" is the name of the
option variable.

A More Complex Example File
---------------------------
The following example illustrates the use of callback functions and
place holder variables. Let us continue with the previous example and
expand on it::

    %description "Example program to show mkgetopt.py"

    # format:
    # long-opt short-opt  struct-member-name type default-value description

    little-endian L     little_end_cb   callback    "Use little-endian format"
    big-endian    B     big_end_cb      callback    "Use big-endian format"

    # We will use this place holder var for use by the callback function
    -             -     use_little_end  int

    jobs      j   njobs       int   1          "Use 'J' jobs simultaneously"
    use-proxy -   use_proxy_p bool false       "Use the default proxy server"
    foreground f  fg_p        bool false       "Run in the foreground"
    debug      -  debug       string "syslog"  "Send debug messages to 'D'"

    log-level  l  loglevel    int?  0          "Default log level"

The output structure generated by "mkgetopt.py" has the following struct
definition::

    struct opt_option
    {
        /* Points to remaining/unconsumed command line arguments.
         * These are unconsumed either because:
         *   1. The argument parsing was explicitly stopped by use of
         *      the "--" command line option.
         *   2. There are no more options (starting with "-" or "--")
         */
        char * const * argv_inputs;

        /*
         * Contains a count of remaining command line arguments in
         * 'argv_inputs' above.
         */
        int     argv_count;

        int help;
        int version;
        void (*little_end_cb)(struct opt_option *, char* arg);
        void (*big_end_cb)(struct opt_option *, char* arg);
        int use_little_end;
        int njobs;
        int use_proxy_p;
        int fg_p;
        char* debug;
        int loglevel;


        /*
         * Boolean flags to denote if any of above vars were recognized
         * during command line processing
         */
        char help_present;
        char version_present;
        char little_end_cb_present;
        char big_end_cb_present;
        char njobs_present;
        char use_proxy_p_present;
        char fg_p_present;
        char debug_present;
        char loglevel_present;

    };
    typedef struct opt_option opt_option;

Our intention is to recognize the option ``--little-endian`` and set the
place holder variable ``use_little_end``. If the option
``--big-endian`` is
set, we want to *reset* the place holder variable. i.e., no matter how
many times the two options are chosen, we always want the place holder
variable ``use_little_end`` to hold the correct value.

In order to accomplish this, we will write two callback functions to
match ``opt_option::little_end_cb`` and ``opt_option::big_end_cb``::

    static void do_little_end(opt_option * opt, char * arg_unused)
    {
        opt->use_little_end = 1; /* Set the place holder var */
    }

    static void do_big_end(opt_option * opt, char * arg_unused)
    {
        opt->use_little_end = 0; /* Reset the place holder var */
    }

Next, in "main()" we will do the following::

    int main(int argc, char * argv[])
    {
        opt_option opt;

        memset(&opt, 0, sizeof opt);

        /* Setup the two callback functions */
        opt.little_end_cb   = do_little_end;
        opt.big_end_cb      = do_big_end;

        /* Lets say that by default, we want "use_little_end" to be
         * true.
         */
         opt.use_little_end = 1;

        if ( 0 != opt_parse (&opt, argc, argv) )
            exit (1);

        /*
         * Now, use_little_end will be 0 or 1 and nothing else.
         */
        if (opt.use_little_end)
        {
            /* Do stuff  .. */
        }
        else
        {
            /* do other stuff .. */
        }

        ...
    }

The above example shows how to use callback functions and "mkgetopt.py".

RANT
====
Many of you will say, "Hey, there is a GNU gengetopt package already.
Why did you waste your time doing this?". There are many reasons:

*   Because I can!

*   The last time I tried to use gengetopt on Win32, It wouldn't
    compile. And, Cygwin doesn't count as a development environment. So,
    Python becomes the obvious *portable* choice for this kind of a tool.

*   I don't like the "configure;make;make install" idiom. Have you
    looked at the relative sizes of the gengetopt ".c" and ".h" files
    vs. autoconf crapware? The last time I checked, the configure script
    was an order of magnitude bigger than the source code itself!

    It is fairly easy to write a package which compiles with _one_
    makefile for Windows, Linux or any Unix. Almost all of general
    purpose programs can be written using the Standard "C" library and
    not relying on arcane features specific to certain OSes. If one
    needs OS specific features, write a common wrapper API and implement
    it for each specific OS platform flavor (e.g., POSIX-flavor,
    Win32-flavor etc.)

*   The C pre-processor (CPP) is evil and ought to be outlawed. People
    abuse it in the name of writing "portable" programs. And, GNU
    "autoconf" re-inforces the myth and the bad habit.

    IMO, the C pre-processor is a very effective tool to hide
    programmer's lack of coding skills. Repeated use of the CPP leads to
    tunnel vision and quickly, the programmer reaches a sorry state
    where they can't write any code without using a *lot* of CPP macros
    and autoconf.

    There are cleaner ways of dealing with portability issues without
    resorting to C Pre-processor messiness.


AUTHOR
======
This program is written by Sudhi Herle <sudhi-at-herle.net>.

LICENSE
=======
This script is licensed under the GNU General Public License ("GPL")
version 2. Please see http://www.gnu.org/licenses/gpl.html for the terms
and conditions of GPL v2.

The code generated by this script is NOT subject to the terms of the GPL
- you are free to license the code generated by this script under
whatever terms you desire.

BUGS
====
If you find any bugs in this script, do one of the following:

1. Fix it yourself and send me a patch.
2. Learn enough Python to fix it yourself and send me a patch.
3. Ask a friend who knows Python to fix it and send me a patch.
4. Ask a friend's friend who knows Python to fix it and send me a patch.
5. If your friend doesn't know anyone who knows Python, get new friends.
   Go back to Step #3.

COLOPHON
========
This document is written using the reStructured Text markup language,
and published with the corresponding Python Docutils processing system. 
Information is available at http://docutils.sourceforge.net/

.. vim: ft=rst:sw=4:ts=4:expandtab:tw=82:notextmode:
